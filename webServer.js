"use strict";
/* Copyright Â© 2017 Kevin O'Connell. All rights reserved. */

/* jshint node: true */

/*
 * This webserver listens, alternatively, to port 3000 for testing on LOCALHOST:3000
 * or to process.env.PORT, the environment variable generated by Heroku for the port 
 * for this instance of the server.
 *
 * Note that anyone able to connect to localhost:portNo will be able to fetch any file accessible
 * to the current user in the current directory or any of its children.
 */


/*************************
 * Module Initialization *
 *************************/

var mongoose = require('mongoose');
var async = require('async');
var session = require('cookie-session');
var bodyParser = require('body-parser');
var multer = require('multer');
var processFormBody = multer({storage: multer.memoryStorage()}).single('uploadedphoto');
var fs = require("fs");
var moment = require('moment');


/*************************
 * Mailgun Configuration *
 *************************/

var api_key = 'key-ece022f0c8744e81048d3135494b164b';
var domain = 'invite.ddx.exchange';
var mailgun = require('mailgun-js')({apiKey: api_key, domain: domain});


/**************************
 * Database Configuration *
 **************************/

// Load the Mongoose schema for User, Photo, and SchemaInfo
var User = require('./schema/user.js');
var Proposal = require('./schema/proposal.js');
var Comment = require('./schema/comment.js');
var Amendment = require('./schema/amendment.js');
var Group = require('./schema/group.js')
var SchemaInfo = require('./schema/schemaInfo.js');

var express = require('express');
var app = express();

/* Connect to mLab Mongoose using the secret environment variable generated by 
 * Heroku for this instance. */
const mongoURI = process.env.MONGODB_URI || "mongodb://localhost/myapp";
mongoose.connect(mongoURI);

/**************************
 * Passport Configuration *
 **************************/

var passport = require('passport');
var LocalStrategy = require('passport-local').Strategy;

passport.use(new LocalStrategy({
    usernameField: 'email_address'
  },
  function(username, password, done) {
    User.findOne({ email_address: username }, function (err, user) {
      if (err) { return done(err); }
      // Return if user not found in database
      if (!user) {
        return done(null, false, {
          message: 'User not found'
        });
      }
      // Return if password is wrong
      if (!user.validPassword(password)) {
        return done(null, false, {
          message: 'Password is wrong'
        });
      }
      // If credentials are correct, return the user object
      return done(null, user);
    });
  }
));

app.use(passport.initialize());

/*************************
 * Session Configuration *
 *************************/

// We have the express static module (http://expressjs.com/en/starter/static-files.html) do all
// the work for us.
app.use(express.static(__dirname));
// For the session we give it the key, and other parameters that it needs to know
// in order for the program to start using it. Session is used for maintaining 
// session state across different request handlers, so you can know whether or not
// a user is logged in.
app.use(session({
    secret: 'secretKey', 
    //secret: process.env.SECRET_KEY,
    resave: false,
    saveUninitialized: false
}));

// bodyParser is used in photo uploads. 
app.use(bodyParser.json());

app.get('/', function (request, response) {
    response.send('Simple web server of files from ' + __dirname);
});

/*
 * URL /session - Returns whether there is an active session
 */
app.get('/session', function(request, response) {

    if (request.session.login_name) {
        response.end(JSON.stringify(true));
    } else {
        response.end(JSON.stringify(false));
    }
});

/*
 * URL /current-session - Returns the current session, to be saved
 * in local storage for purposes of restoring the session
 */
app.get('/get-current-session', function(request, response) {

    console.log("returning current session", JSON.stringify(request.session));
    response.end(JSON.stringify(request.session));
});

/*
 * URL /restore-session - Returns the current session from the session
 * saved in local storage and returns the user associated with that session's
 * user.
 */
 // TODO: Speak with an experienced developer about how to improve security here. Salting passwords? 
 // TODO: What are the risks associated with keeping session data stored on local machine?
app.post('/restore-session', function(request, response) {

    var email_address = request.body.email_address;
    console.log("Restoring session for user with email_address:", email_address);

    User.findOne({email_address: email_address}, function (err, user) {    
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!user) {
            // If no user found, report an error.
            response.status(400).send('Missing user');
            return;
        }
        if (user.length === 0) {
            // Query didn't return an error but didn't find the SchemaInfo object
            console.log("user.length === 0");
            response.status(400).send('Missing user');
            return;
        }

        // Create new session, which will be part of the request, so we have access on all routes
        request.session.email_address = email_address;
        request.session.user_id = user._id;
        request.session.user = user;

        // Send session back
        console.log('user', user);
        //response.send(session);
        response.end(JSON.stringify(user));
    }); 
});


/***********************************
 * Login and Registration Handling *
 ***********************************/

/* If a user has entered a valid login_name and password combination,
 * logs in as that account. 
 */
app.post('/admin/login', function (request, response) {

    var email_address = request.body.email_address;
    var password = request.body.password;

    // Use passport local strategy to authenticate from email_address and password stored locally
    console.log("About to authenticate user");
    passport.authenticate('local', function(err, user, info){
        console.log("Authentication successful");
        var token;

        // If Passport throws/catches an error
        if (err) {
          response.status(404).json(err);
          return;
        }

        // TODO: Rework this so one call is to retrieve the token, and another is to retrieve the active user (*sigh*)
        // If a user is found
        if(user){
            request.session.email_address = email_address;
            request.session.user_id = user._id;
            request.session.user = user;               
            token = user.generateJwt();
            user.token = token;
            console.log('user', user);
            response.end(JSON.stringify(user));
            //response.status(200);
            // response.json({
            //     "token" : token
            // });                       
        } else {
          // If user is not found
          response.status(401).json(info);
        }
    })(request, response);     
});

// Logout from the current account
app.post('/admin/logout', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    } else {
        // request.session.destroy(function (err) {
        //     if (err) {
        //         response.status(500).send(err);
        //         return;
        //     }
        //     response.send("Logout success");
        // });
        request.session = null;
        response.send("Logout success");
    }
});

// Register a new user
app.post('/admin/register', function (request, response) {

    console.log("app.post: registering a new user");

    // If a user with the entered login name already exists, return an error
    User.findOne({email_address: request.body.email_address}, function (err, user) {
        if (user) {
            response.status(400).send('That user already exists');
            return;
        }

        var user = new User();

        user.email_address = request.body.email_address; // Email Address / Login
        user.first_name = request.body.first_name; // First name of the user.
        user.last_name = request.body.last_name;  // Last name of the user.
        user.description = request.body.description;  // A brief user description
        user.group_invitations = [];

        console.log("Searching for groups that the user has been invited to join");
        // Find any groups that the user has been invited to join
        Group.find({invited_members: request.body.email_address}).select('_id').exec(function(err, groups){
            console.log("The user has been invited to join ", groups);
            // Add the _id of each group to the user's group_invitations array
            for (var i = 0; i < groups.length; i++) {
                user.group_invitations.push(groups[i]._id);
            }
            console.log("user.group_invitations now =", user.group_invitations);
            user.save();
        });

        user.setPassword(request.body.password);    

        user.save(function(err) {
            var token;
            token = user.generateJwt();
            response.status(200);
            response.json({
                "token" : token
            });
            console.log("Created userObject with ID", user._id);
            response.end(JSON.stringify(user));        
        });    
    });
});

/*****************************************
 * Group Retrieval and Creation Handling *
 *****************************************/

/*
 * URL /groups/new - Enter a new group in the database
 */
app.post('/groups/new', function (request, response) {

    console.log("Server received group upload request");

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var members = request.body.members.push(request.session.user_id);

    var group_attributes = {
        name: request.body.name, // Name of the group
        description: request.body.description, // Description of the group
        //members: members, // Reference array of the IDs of the users who are in the group
        administrators: request.session.user_id // Reference array of the IDs of the administrators of this group        
    };

    function doneCallback(err, newGroup) {
        console.log("Created group object with ID", newGroup._id);

        // Add the newly created group to the session user's groups
        User.findOne({_id: request.session.user._id}, function (err, user) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (!user) {
                // If no user found, report an error.
                response.status(400).send('Missing user');
                return;
            }
            if (user.length === 0) {
                // Query didn't return an error but didn't find the SchemaInfo object
                console.log("user.length === 0");
                response.status(400).send('Missing user');
                return;
            }

            newGroup.members.push(request.session.user_id);
            newGroup.save();
            user.groups.push(newGroup._id);
            user.save();
            response.end(JSON.stringify(newGroup));
        });         
    }

    console.log("Creating group with attributes: ", group_attributes);
    Group.create(group_attributes, doneCallback);
});

/*
 * URL /groups/retrieve - Retrieve the groups associated with the active user
 */
app.get('/groups/retrieve', function (request, response) {

    console.log("Server received group retrieval request");

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    // Get the active user to retrieve the list of their groups
    User.findOne({_id: request.session.user._id}).select('groups').exec(function (err, user) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!user) {
            // If no user found, report an error.
            response.status(400).send('Missing user');
            return;
        }
        if (user.length === 0) {
            // Query didn't return an error but didn't find the SchemaInfo object
            console.log("user.length === 0");
            response.status(400).send('Missing user');
            return;
        }

        var groups = user.groups;
        console.log("Retrieving groups with IDs ", groups);        

        // Retrieve all groups associated with the active user
        Group.find({_id: groups}).exec(function (err, groups) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (!groups) {
                response.status(400).send("Missing groups");
                return;
            }
            if (groups.length === 0) {
                // Query didn't return an error but didn't find the SchemaInfo object - This
                // is also an internal error return.
                var empty_array = [];
                response.status(200).send(JSON.stringify(empty_array));
                return;
            }

            // We got the object - create an array version of it in JSON
            var groupsArray = JSON.parse(JSON.stringify(groups));
            console.log('groups', groups);
            response.end(JSON.stringify(groups));
        });        
    });         
});

/*
 * URL /groups/retrieve/members-count/:group_id - Retrieve the number of members
 * in the group specified by group_id
 */
app.get('/groups/retrieve/members-count/:group_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var group_id = request.params.group_id;
    console.log("Server received request to retrieve the number of members in the group with _id ", group_id);    

    // Retrieve the members of the group with group_id
    Group.findOne({_id: group_id}).select('members').exec(function (err, group) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!group) {
            // If no group found, report an error.
            response.status(400).send('Missing group');
            return;
        }

        var member_ids = group.members;
        console.log("Retrieving the array of members with IDs ", member_ids);
        response.end(JSON.stringify(member_ids));       
    });         
}); 

/*
 * URL /groups/invitations/retrieve - Retrieve the groups that the user
 * has been invited to join
 */
app.get('/groups/invitations/retrieve', function (request, response) {

    console.log("Server received group invitation retrieval request");

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    // Get the active user to retrieve the list of their groups
    User.findOne({_id: request.session.user._id}).select('group_invitations').exec(function (err, user) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!user) {
            // If no user found, report an error.
            response.status(400).send('Missing user');
            return;
        }
        if (user.length === 0) {
            // Query didn't return an error but didn't find the SchemaInfo object
            console.log("user.length === 0");
            response.status(400).send('Missing user');
            return;
        }

        var group_invitations = user.group_invitations;
        console.log("Retrieving invitations to groups with IDs ", group_invitations);        

        // Retrieve all groups associated with the active user
        Group.find({_id: group_invitations}).exec(function (err, groups) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (!groups) {
                response.status(400).send("Missing groups");
                return;
            }
            if (!groups.length) {
                // Query didn't return an error but didn't find the SchemaInfo object - This
                // is also an internal error return.
                var empty_array = [];
                response.status(200).send(JSON.stringify(empty_array));
                return;
            }

            // We got the object - create an array version of it in JSON
            var group_invitations_array = JSON.parse(JSON.stringify(groups));
            console.log('group_invitations_array', group_invitations_array);
            response.send(group_invitations_array);
        });        
    });         
}); 

/*
 * URL /groups/retrieve/members/:group_id - Retrieve the members associated with group_id
 */
app.get('/groups/retrieve/members/:group_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var group_id = request.params.group_id;
    console.log("Server received group member request for group with id ", group_id);    

    // Retrieve the members of the group with group_id
    Group.findOne({_id: group_id}).select('members').exec(function (err, group) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!group) {
            // If no group found, report an error.
            response.status(400).send('Missing group');
            return;
        }

        var member_ids = group.members;
        console.log("Retrieving members with IDs ", member_ids);        

        // Retrieve all members associated with the group
        User.find({_id: member_ids}).exec(function (err, members) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (members.length === 0) {
                // Query didn't return an error but didn't find the SchemaInfo object - This
                // is also an internal error return.
                response.status(200).send('Missing members');
                return;
            }

            // We got the object - create an array version of it in JSON
            console.log('Retrieved members ', members);
            response.end(JSON.stringify(members));
        });        
    });         
}); 


/*
 * URL /groups/retrieve/administrators/:group_id - Retrieve the members associated with group_id
 */
app.get('/groups/retrieve/administrators/:group_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var group_id = request.params.group_id;
    console.log("Server received group administrator request for group with id ", group_id);    

    // Retrieve the administrators of the group with group_id
    Group.findOne({_id: group_id}).select('administrators').exec(function (err, group) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!group) {
            // If no group found, report an error.
            response.status(400).send('Missing group');
            return;
        }

        var admin_ids = group.administrators;
        console.log("Retrieving administrators with IDs ", admin_ids);        

        // Retrieve all administrators associated with the group
        User.find({_id: admin_ids}).exec(function (err, administrators) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (administrators.length === 0) {
                // Query didn't return an error but didn't find the SchemaInfo object - This
                // is also an internal error return.
                response.status(200).send('Missing members');
                return;
            }

            // We got the object - create an array version of it in JSON
            console.log('Retrieved administrators ', administrators);
            response.end(JSON.stringify(administrators));
        });        
    });         
}); 

/*
 * URL /groups/invite/members/:group_id - Add the members specified by the IDs
 * contained in the body parameter invited_member_emails to join the group specified by
 * group_id
 */
app.post('/groups/invite/members/:group_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var group_id = request.params.group_id;
    var invited_member_emails = request.body.invited_member_emails;
    console.log("Server received request to invite users with the email addresses ", invited_member_emails, " to join group with id ", group_id);    

    // Retrieve the array of invited members from group with group_id
    Group.findOne({_id: group_id}).select('invited_members').exec(function (err, group) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!group) {
            // If no group found, report an error.
            response.status(400).send('Missing group');
            return;
        }

        console.log("Retrieving invited members ", group.invited_members);

        // Add the invited_member_emails to the invited_members array for this group
        // TODO: On the front end, do not give the user the option to invite members who have already been invited
        for (var i = 0; i < invited_member_emails.length; i++) {
            // If the user has not already been invited to join the group
            if (!(group.invited_members.indexOf(invited_member_emails[i]) > -1)) {
                
                group.invited_members.push(invited_member_emails[i]);

                // Send an email to the user notifying them that they have been invited to join DDX
                console.log("******** Sending invitation email to", invited_member_emails[i]);
                var data = {
                  from: 'Excited User <postmaster@invite.ddx.exchange>',
                  to: invited_member_emails[i],
                  subject: 'Hello',
                  text: 'Testing some Mailgun awesomness!'
                };     

                mailgun.messages().send(data, function (error, body) {
                  console.log(body);
                });  
                
                // Add the group_id to the group_invitations of the invited user
                User.findOne({email_address: invited_member_emails[i]}).select('group_invitations').exec(function (err, user) {
                    if (err) {
                        // Query returned an error.
                        response.status(400).send(JSON.stringify(err));
                        return;
                    }
                    if (!user) {
                        // If no user found, report an error.
                        response.status(400).send('Missing group');
                        return;
                    }

                    // Add group_id to user.group_invitations if its not already there
                    if (!(user.group_invitations.indexOf(group_id) > -1)) {
                        user.group_invitations.push(group_id);                      
                    }
                    user.save();
                });
            }            
        }
        group.save();

        // Return the group with the newly added members
        console.log('invited_members now contains ', group.invited_members);
        response.end(JSON.stringify(group));       
    });         
});


/*
 * URL /groups/invite/new-members/:group_id - 
 * 1) Add the email addresses in the array invited_member_emails to the
 * invite_members array for the group with group_id.
 * 2) Send each invited member an email inviting them to register for DDX
 * and to join the group.
 */
app.post('/groups/invite/new-members/:group_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var group_id = request.params.group_id;
    var invited_member_emails = request.body.invited_member_emails;
    console.log("Server received request to invite new users with the email addresses ", invited_member_emails, " to join group with id ", group_id);    

    // Retrieve the array of invited members from group with group_id
    Group.findOne({_id: group_id}).select('invited_members').exec(function (err, group) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!group) {
            // If no group found, report an error.
            response.status(400).send('Missing group');
            return;
        }

        console.log("Retrieving invited members ", group.invited_members);

        // Add the invited_member_emails to the invited_members array for this group
        // TODO: On the front end, do not give the user the option to invite members who have already been invited
        for (var i = 0; i < invited_member_emails.length; i++) {
            if (!(group.invited_members.indexOf(invited_member_emails[i]) > -1)) {
                
                group.invited_members.push(invited_member_emails[i]);                
            }            
        }
        group.save();

        // Return the group with the newly added members
        console.log('invited_members now contains ', group.invited_members);
        response.end(JSON.stringify(group));       
    });         
});

/*
 * URL /groups/invitation/accept/:group_id - Add the session user to the group identified by
 * the body parameter group_id, then remove that user from the array of invited users
 * and remove the group_id from the user's array of group invitations
 */
app.post('/groups/invitation/accept/:group_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var group_id = request.params.group_id;
    console.log("Server received accept group invitation request for group with id ", group_id);    

    // Retrieve the array of invited members from group with group_id
    Group.findOne({_id: group_id}).select('invited_members members').exec(function (err, group) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!group) {
            // If no group found, report an error.
            response.status(400).send('Missing group');
            return;
        }

        console.log("Retrieving invited members ", group.invited_members, " removing from group");

        // Add the session user to the group
        group.members.push(request.session.user._id);

        // Remove the session user from group.invited_members
        group.invited_members.splice(group.invited_members.indexOf(request.session.email_address));

        // Retrieve the session user
        User.findOne({_id: request.session.user._id}).select('group_invitations groups').exec(function(err, user) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (!user) {
                // If no user found, report an error.
                response.status(400).send('Missing group');
                return;
            }

            // Remove group_id from the user's invitation array
            user.group_invitations.splice(user.group_invitations.indexOf(group_id), 1);

            // Add group_id to the user's groups array
            user.groups.push(group_id);
            user.save();
        });

        // Retrieve the proposals associated with this group and update the voting_members array
        Proposal.find({group: group._id}).select('_id').exec(function(err, proposals){
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (!proposals) {
                // If no user proposals, report an error.
                response.status(400).send('Missing proposals');
                return;
            }

            var proposalsArray = JSON.parse(JSON.stringify(proposals));

            async.each(proposalsArray, function (proposal, proposal_done) {
                Proposal.findOne({_id: proposal._id}).select('voting_members').exec(function(err, curr_proposal){
                    curr_proposal.voting_members.push(request.session.user._id);
                    curr_proposal.save();
                });
                proposal_done();
            });
        });

        group.save();

        // Add the group_id to the session user's groups
        request.session.user.groups.push(group_id);        

        // Return the group with the newly added members
        console.log('members now contains ', group.members);
        response.send(JSON.stringify(group));       
    });         
});

/*
 * URL /users/retrieve/members - Retrieve the users that the active user is
 * connected to
 */
app.get('/users/retrieve/members', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to retrieve users");

    // Retrieve all users 
    // TODO: Add search criteria to limit search to users that the active user is connected to
    User.find({}).exec(function (err, users) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (users.length === 0) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(200).send('Missing users');
            return;
        }

        // We got the object - create an array version of it in JSON
        console.log('Retrieved users ', users);
        response.end(JSON.stringify(users));
    });             
}); 

/**********************************************
 * Proposal Submission and Retrieval Handling *
 **********************************************/

/*
 * URL /proposals/new - Enter a new proposal in the database
 */
app.post('/proposals/new', function (request, response) {

    console.log("Server received proposal upload request");

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var proposal_attributes = {
        title: request.body.title, // Proposal title
        text: request.body.text, // Text of the proposal
        description: request.body.description, // The proponent's description of the proposal
        user_author_id: request.session.user_id, // Reference to the ID of the user who submitted the proposal
        user_author_name: request.session.user.first_name + " " + request.session.user.last_name,
        group: request.body.group, // Reference to the ID of the group that this proposal was submitted to
        status: 0 // Set status to 0: Under Discussion
    };

    function doneCallback(err, newProposal) {

        // Retrieve the proposal's group, and add the group's name to the proposal
        // TODO: Do I need to add the proposal to the group? Perhaps not, because I can search by the proposal
        Group.findOne({_id: request.body.group}).exec(function (err, group) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (group.length === 0) {
                // Query didn't return an error but didn't find the SchemaInfo object - This
                // is also an internal error return.
                response.status(200).send('Missing group');
                return;
            }


            newProposal.group_name = group.name;
            newProposal.floor_threshold_divisor = group.floor_threshold_divisor; 
            newProposal.amendment_threshold_divisor = group.amendment_threshold_divisor;
            newProposal.enactment_divisor = group.enactment_divisor;
            newProposal.setMaxDiscussionTime(group.max_discussion_time);
            newProposal.min_discussion_time = group.min_discussion_time;
            newProposal.voting_time = group.voting_time;
            newProposal.voting_members = group.members;
            newProposal.save();

            // We got the object - create an array version of it in JSON
            console.log("Created proposal ", newProposal);
            response.end(JSON.stringify(newProposal));
        });         
    }

    Proposal.create(proposal_attributes, doneCallback);
});

/*
 * URL /proposals/retrieve/:group_id/:status - Retrieve the proposals associated with a group
 */
app.get('/proposals/retrieve/:group_id/:status', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    // TODO: This is HACKY AF. Replace with an interval function ASAP.
    // Every time a user requests to retrieve the proposals, iterate through all existing proposals
    // to determine if they should be reclassified as enacted, rejected, etc.
    Proposal.find({}).exec(function (err, proposals) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (!proposals) {
            response.status(400).send('Missing proposals');
            return;
        }
        if (proposals.length === 0) {
            // Query didn't return an error but didn't find the SchemaInfo object - This
            // is also an internal error return.
            // var empty_array = [];
            // response.status(200).send(JSON.stringify(empty_array));
            response.status(200).send('Missing object');
            return;
        }

        var proposalArray = JSON.parse(JSON.stringify(proposals));
        // Iterate through each proposal and determine if it should be moved
        async.each(proposalArray, function (proposal, proposal_done) {
            Proposal.findOne({_id: proposal._id}).exec(function(err, curr_proposal) {

                // If a proposal is under discussion:
                if (proposal.status === 0) {
                    // A: Determine if proposal should be moved from discussion to the floor
                    var num_voters = curr_proposal.voting_members.length;
                    var req_votes = (num_voters/curr_proposal.floor_threshold_divisor);
                    console.log("**** This proposal requires ", req_votes, "upvotes to move to the floor. It currently has", curr_proposal.users_who_upvoted.length, "votes");
                    if (curr_proposal.users_who_upvoted.length >= req_votes) {
                        console.log("This proposal has recieved enough upvotes to move to the floor");
                        curr_proposal.status = 1;
                        curr_proposal.setVotingCloses();
                        curr_proposal.save();
                    } else {
                        // B: If proposal's discussion time has elapsed, move it to rejected 
                        var max_discussion_moment = moment(curr_proposal.max_discussion_time);
                        var now_moment = moment();
                        if (max_discussion_moment.isBefore(now_moment)) {
                            console.log("This proposal has not received enough upvotes in time. It is getting moved to rejected");
                            curr_proposal.status = 3;
                            curr_proposal.save();
                        }
                    }
                }

                // If a proposal is on the floor
                if (proposal.status === 1) {
                    // If the proposals' time has expired:
                    if (moment(curr_proposal.voting_closes).isBefore(moment(Date.now))) {
                        if (proposal.users_who_voted_yes.length > proposal.users_who_voted_no.length) {
                            console.log("This proposal has been enacted");
                            proposal.status = 2;
                        } else {
                            console.log("This proposal has been rejected");
                            proposal.status = 3;
                        }
                    }
                }
                proposal_done();
            });
        /* Finally, report an error if necessary or return the photoArray */
        }, function (err) {
            if (err) {
                response.status(500).send(JSON.stringify(err));
            } else {
                console.log('Updated proposals', proposalArray);
            }
        });            
    });

    var group_id = request.params.group_id;
    var status = request.params.status;
    //console.log("Server received request to retrieve proposals for group", group_id);    

    // If no group selected, retrieval all proposals to which the user has access
    if (typeof group_id === "undefined" || group_id === "all") {
        var groups = request.session.user.groups;
        //console.log("group_id === undefined, retrieving all proposals for the groups with ids", groups);
        Proposal.find({group: groups, status: status}).exec(function (err, proposals) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (!proposals) {
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (proposals.length === 0) {
                // Query didn't return an error but didn't find the SchemaInfo object - This
                // is also an internal error return.
                // var empty_array = [];
                // response.status(200).send(JSON.stringify(empty_array));
                response.status(200).send('Missing object');
                return;
            }

            // We got the object - create an array version of it in JSON
            var proposalsArray = JSON.parse(JSON.stringify(proposals));
            console.log('proposals', proposals);
            response.end(JSON.stringify(proposals));
        });
    // Otherwise, retrieve the proposals associated with the selected group        
    } else {
        //console.log("group_id is defined, retrieving proposals for that group");
        // Retrieve all proposals with TODO: add group / active query qualifiers
        Proposal.find({group: group_id, status: status}).exec(function (err, proposals) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (proposals.length === 0) {
                // Query didn't return an error but didn't find the SchemaInfo object - This
                // is also an internal error return.
                var empty_array = [];
                response.status(200).send(JSON.stringify(empty_array));
                return;
            }

            // We got the object - create an array version of it in JSON
            var proposalsArray = JSON.parse(JSON.stringify(proposals));
            //console.log('proposals', proposals);
            response.end(JSON.stringify(proposals));
        });        
    };
});    

/*
 * URL /proposals/discussion/:proposal_id - Retrieve the proposal specified by 
 * the request parameter :proposal_id, and retrieve associated comments
 */
app.get('/proposals/discussion/get/:proposal_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var proposal_id = request.params.proposal_id;
    //console.log("Server received request to retrieve proposal with id", proposal_id);

    // Retrieve all proposals with TODO: add group / active query qualifiers
    Proposal.findOne({_id: proposal_id}).exec(function (err, proposal) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (proposal === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Proposal does not exist');
            return;
        }

        //console.log('Retrieved proposal:', proposal);
        response.end(JSON.stringify(proposal));        
    });
});

/*
 * URL /proposals/discussion/get_comments/:proposal_id - Retrieve the comments 
 * associated with the proposal_id received as a request parameter
 */
app.get('/proposals/discussion/get_comments/:proposal_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var proposal_id = request.params.proposal_id;
    //console.log("Server received request to retrieve comments associated with proposal id", proposal_id);

    // Retrieve all comments associated with the proposal_id
    Comment.find({proposal_id: proposal_id}).exec(function (err, comments) {
        if (err) {
            // Query returned an error
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (comments.length === 0) {
            var empty_array = [];
            response.status(200).send(JSON.stringify(empty_array));
            return;
        }

        //console.log("Retrieved comments: ", comments);
        response.end(JSON.stringify(comments));
    });
});

/*
 * URL /proposals/discussion/get_amendments/:proposal_id - Retrieve the amendments 
 * associated with the proposal_id received as a request parameter
 */
app.get('/proposals/discussion/get_amendments/:proposal_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var proposal_id = request.params.proposal_id;
    console.log("Server received request to retrieve amendments associated with proposal id", proposal_id);

    // Retrieve all amendments associated with the proposal_id
    Amendment.find({proposal_id: proposal_id}).exec(function (err, amendments) {
        if (err) {
            // Query returned an error
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (amendments.length === 0) {
            var empty_array = [];
            response.status(200).send(JSON.stringify(empty_array)); 
            return;
        }

        console.log("Retrieved amendments: ", amendments);
        response.end(JSON.stringify(amendments));
    });
});

/*
 * URL /proposals/discussion/get_comments_and_amendments/:proposal_id - Retrieve the 
 * comments and amendments associated with the proposal_id received as a request parameter
 */
app.get('/proposals/discussion/get_comments_and_amendments/:proposal_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    var proposal_id = request.params.proposal_id;
    console.log("Server received request to retrieve comments and amendments associated with proposal id", proposal_id);

    var commentArray = [];
    var amendmentArray = [];

    function doneAmendmentCallback() {
        console.log("doneAmendmentCallback() called");
        var combinedArray = commentArray.concat(amendmentArray);
        console.log("Retrieved combined array: ", combinedArray);
        response.end(JSON.stringify(combinedArray));
    };

    function doneCommentCallback() {
        console.log("doneCommentCallback() called");
        // Retrieve all amendments associated with the proposal_id
        Amendment.find({proposal_id: proposal_id}).exec(function (err, amendments) {
            if (err) {
                // Query returned an error
                response.status(400).send(JSON.stringify(err));
                return;
            }

            console.log("Retrieved amendments: ", amendments);
            // Store the retreived amendments in an array
            amendmentArray = JSON.parse(JSON.stringify(amendments));
            doneAmendmentCallback();
        });
    };

    // Retrieve all comments associated with the proposal_id
    Comment.find({proposal_id: proposal_id}).exec(function (err, comments) {
        console.log("Comment.find() called");
        if (err) {
            // Query returned an error
            response.status(400).send(JSON.stringify(err));
            return;
        }

        console.log("Retrieved comments: ", comments);
        // Store the retrieved comments in an array
        commentArray = JSON.parse(JSON.stringify(comments));
        doneCommentCallback();
    }); 
});

/*****************************************
 * Proposal Upvote and Downvote Handling *
 *****************************************/

/*
 * URL /proposals/upvote/:id - Adds an upvote to the proposal specified by :id
 * and records that the session user upvoted that proposal
 */
app.post('/proposals/upvote/:proposal_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to upvote proposal with id", request.params.proposal_id);
    var proposal_id = request.params.proposal_id;
    var user_id = request.session.user_id;

    // Find the proposal with proposal_id
    Proposal.findOne({_id: proposal_id}).exec(function (err, proposal) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (proposal === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Proposal does not exist');
            return;
        }

        var upvoteUserIndex = proposal.users_who_upvoted.indexOf(user_id);
        var downvoteUserIndex = proposal.users_who_downvoted.indexOf(user_id);
        if (upvoteUserIndex >-1) {
           console.log("User has already upvoted this proposal");
        } else {
           console.log("User has not yet upvoted this proposal");
           proposal.users_who_upvoted.push(user_id);
           console.log("proposal.users_who_upvoted = ", proposal.users_who_upvoted);
           // If user had previously downvoted, remove from downvote array
           if (downvoteUserIndex >-1) {
                proposal.users_who_downvoted.splice(downvoteUserIndex, 1);
           }
        }
        console.log("proposal.users_who_upvoted = ", proposal.users_who_upvoted);        
        proposal.save();
        response.send(JSON.stringify(proposal));
    });
});

/*
 * URL /proposals/downvote/:id - Adds downvote to the proposal specified by :id
 * and records that the session user downvoted that proposal
 */
app.post('/proposals/downvote/:proposal_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to downvote proposal with id", request.params.proposal_id);
    var proposal_id = request.params.proposal_id;
    var user_id = request.session.user_id;

    // Find the proposal with proposal_id
    Proposal.findOne({_id: proposal_id}).exec(function (err, proposal) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (proposal === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Proposal does not exist');
            return;
        }

        var upvoteUserIndex = proposal.users_who_upvoted.indexOf(user_id);
        var downvoteUserIndex = proposal.users_who_downvoted.indexOf(user_id);
        if (downvoteUserIndex >-1) {
           console.log("User has already downvoted this proposal");
        } else {
           console.log("User has not yet downvoted this proposal");
           proposal.users_who_downvoted.push(user_id);
           console.log("proposal.users_who_downvoted = ", proposal.users_who_downvoted);
           // If user had previously upvoted, remove from upvote array
           if (upvoteUserIndex >-1) {
                proposal.users_who_upvoted.splice(upvoteUserIndex, 1);
           }
        }

        proposal.save();
        response.send(JSON.stringify(proposal));
    });
});

/******************************************
 * Comment Submission and Voting Handling *
 ******************************************/

/*
 * URL /comments/new - Enter a new comment in the database
 */
app.post('/comments/new', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received comment upload request");

    var comment_attributes = {
        text: request.body.text, // Text of the comment
        user_author_name: request.session.user.first_name + " " + request.session.user.last_name, // Comment author name
        user_author_id: request.session.user_id, // Reference to the ID of the user who submitted the comment
        proposal_id: request.body.proposal_id, // Reference to the ID of the proposal to which the comment responds
        is_comment: true, // Specifies that this object is a comment
    };

    function doneCallback(err, newComment) {
        console.log("Created comment object with ID", newComment._id);
        Proposal.findOne({_id: newComment.proposal_id}).exec(function (err, proposal) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (proposal === null) {
                // Query didn't return an error but didn't find the SchemaInfo object
                response.status(500).send('Proposal does not exist');
                return;
            }            
            proposal.comments.push(newComment._id);
            proposal.save();
            response.end(JSON.stringify(newComment));
        });        
    }

    Comment.create(comment_attributes, doneCallback);

});

/*
 * URL /comments/upvote/:comment_id - Adds an upvote to the comment
 * specified by :id and records that the session user upvoted that comment
 */
app.post('/comments/upvote/:comment_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to upvote comment with id", request.params.comment_id);
    var comment_id = request.params.comment_id;
    var user_id = request.session.user_id;

    // Find the comment with comment_id
    Comment.findOne({_id: comment_id}).exec(function (err, comment) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (comment === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Comment does not exist');
            return;
        }

        var upvoteUserIndex = comment.users_who_upvoted.indexOf(user_id);
        var downvoteUserIndex = comment.users_who_downvoted.indexOf(user_id);
        if (upvoteUserIndex >-1) {
           console.log("User has already upvoted this comment");
        } else {
           console.log("User has not yet upvoted this comment");
           comment.users_who_upvoted.push(user_id);
           console.log("comment.users_who_upvoted = ", comment.users_who_upvoted);
           // If user had previously downvoted, remove from downvote array
           if (downvoteUserIndex >-1) {
                comment.users_who_downvoted.splice(downvoteUserIndex, 1);
           }
        }

        comment.save();
        response.send(JSON.stringify(comment));
    });
});

/*
 * URL /comments/downvote/:comment_id - Adds downvote to the comment 
 * specified by :comment_id and records that the session user downvoted that comment
 */
app.post('/comments/downvote/:comment_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to downvote comment with id", request.params.comment_id);
    var comment_id = request.params.comment_id;
    var user_id = request.session.user_id;

    // Find the comment with comment_id
    Comment.findOne({_id: comment_id}).exec(function (err, comment) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (comment === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Comment does not exist');
            return;
        }

        var upvoteUserIndex = comment.users_who_upvoted.indexOf(user_id);
        var downvoteUserIndex = comment.users_who_downvoted.indexOf(user_id);
        if (downvoteUserIndex >-1) {
           console.log("User has already downvoted this comment");
        } else {
           console.log("User has not yet downvoted this comment");
           comment.users_who_downvoted.push(user_id);
           console.log("comment.users_who_downvoted = ", comment.users_who_downvoted);
           // If user had previously upvoted, remove from upvote array
           if (upvoteUserIndex >-1) {
                comment.users_who_upvoted.splice(upvoteUserIndex, 1);
           }
        }

        comment.save();
        response.send(JSON.stringify(comment));
    });
});


/********************************************
 * Amendment Submission and Voting Handling *
 ********************************************/

/*
 * URL /amendments/new - Enter a new amendment in the database
 */
app.post('/amendments/new', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received amendment upload request");

    var amendment_attributes = {
        amendment_text: request.body.text, // Text of the amendment
        amendment_description: request.body.description, // Description of the amendment
        original_proposal_text: request.body.original_proposal_text, // Text of the original proposal to be amended
        user_author_name: request.session.user.first_name + " " + request.session.user.last_name, // Amendment author name
        user_author_id: request.session.user_id, // Reference to the ID of the user who submitted the amendment
        proposal_id: request.body.proposal_id, // Reference to the ID of the proposal to be amended
        is_enacted: false, // Set is_encated to false for new amendments
        is_amendment: true, // Specify that this object is an amendment
    };

    function doneCallback(err, newAmendment) {
        console.log("Created amendment object with ID", newAmendment._id);
        Proposal.findOne({_id: newAmendment.proposal_id}).exec(function (err, proposal) {
            if (err) {
                // Query returned an error.
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (proposal === null) {
                // Query didn't return an error but didn't find the SchemaInfo object
                response.status(500).send('Proposal does not exist');
                return;
            }            
            proposal.amendments.push(newAmendment._id);
            proposal.save();
            response.end(JSON.stringify(newAmendment));
        });        
    }

    Amendment.create(amendment_attributes, doneCallback);

});

/*
 * URL /amendments/upvote/:amendment_id - Adds an upvote to the amendment
 * specified by :amendment_id and records that the session user upvoted that amendment
 */
app.post('/amendments/upvote/:amendment_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to upvote amendment with id", request.params.amendment_id);
    var amendment_id = request.params.amendment_id;
    var user_id = request.session.user_id;

    // Find the amendment with amendment_id
    Amendment.findOne({_id: amendment_id}).exec(function (err, amendment) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (amendment === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Amendment does not exist');
            return;
        }

        var upvoteUserIndex = amendment.users_who_upvoted.indexOf(user_id);
        var downvoteUserIndex = amendment.users_who_downvoted.indexOf(user_id);
        if (upvoteUserIndex >-1) {
           console.log("User has already upvoted this amendment");
        } else {
           console.log("User has not yet upvoted this amendment");
           amendment.users_who_upvoted.push(user_id);
           console.log("comment.users_who_upvoted = ", amendment.users_who_upvoted);
           // If user had previously downvoted, remove from downvote array
           if (downvoteUserIndex >-1) {
                amendment.users_who_downvoted.splice(downvoteUserIndex, 1);
           }
        }
        console.log("About to search this amendment's proposal");
        // Then find the proposal and determine if the amendment shall be enacted
        Proposal.findOne({_id: amendment.proposal_id}).exec(function (err, proposal) {
            console.log("Searched for proposal");
            if (err) {
                response.status(400).send(JSON.stringify(err));
                return;
            }
            if (proposal === null) {
                response.status(500).send('Proposal does not exist');
                return;
            }

            var num_voters = proposal.voting_members.length;
            var req_votes = (num_voters/proposal.amendment_threshold_divisor);
            console.log("**** This amendment requires ", req_votes, "upvotes to enact. It currently has", amendment.users_who_upvoted.length, "votes");
            if (amendment.users_who_upvoted.length >= req_votes) {
                console.log("This amendment has recieved enough upvotes to enact");
                proposal.text = amendment.amendment_text;
                amendment.is_enacted = true;
                amendment.time_enacted = Date.now();
                proposal.save();
            }
            amendment.save();
            response.send(JSON.stringify(amendment));
        });
    });
});

/*
 * URL /amendments/downvote/:amendment_id - Adds downvote to the amendment 
 * specified by :amendment_id and records that the session user downvoted that amendment
 */
app.post('/amendments/downvote/:amendment_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to downvote amendment with id", request.params.amendment_id);
    var amendment_id = request.params.amendment_id;
    var user_id = request.session.user_id;

    // Find the amendment with amendment_id
    Amendment.findOne({_id: amendment_id}).exec(function (err, amendment) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (amendment === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Amendment does not exist');
            return;
        }

        var upvoteUserIndex = amendment.users_who_upvoted.indexOf(user_id);
        var downvoteUserIndex = amendment.users_who_downvoted.indexOf(user_id);
        if (downvoteUserIndex >-1) {
           console.log("User has already downvoted this amendment");
        } else {
           console.log("User has not yet downvoted this amendment");
           amendment.users_who_downvoted.push(user_id);
           console.log("amendment.users_who_downvoted = ", amendment.users_who_downvoted);
           // If user had previously upvoted, remove from upvote array
           if (upvoteUserIndex >-1) {
                amendment.users_who_upvoted.splice(upvoteUserIndex, 1);
           }
        }

        amendment.save();
        response.send(JSON.stringify(amendment));
    });
});

/*******************************************
 * Floor Proposal Yes and No Vote Handling *
 *******************************************/

/*
 * URL /proposals/vote/yes/:proposal_id - Adds a yes vote to the proposal specified
 * by :id and records that the session user voted yes on that proposal
 */
app.post('/proposals/vote/yes/:proposal_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to vote yes on proposal with id", request.params.proposal_id);
    var proposal_id = request.params.proposal_id;
    var user_id = request.session.user_id;
    console.log("About to look for proposal");

    // Find the proposal with proposal_id
    // TODO: Add parameters to require that this proposal be up for vote
    Proposal.findOne({_id: proposal_id}).exec(function (err, proposal) {
        console.log("Looking for proposal");
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (proposal === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Proposal does not exist');
            return;
        }

        var yesVoteUserIndex = proposal.users_who_voted_yes.indexOf(user_id);
        var noVoteUserIndex = proposal.users_who_voted_no.indexOf(user_id);
        if (yesVoteUserIndex >-1) {
           console.log("User has already voted yes on this proposal");
        } else {
           console.log("User has not yet voted yes on this proposal");
           proposal.users_who_voted_yes.push(user_id);
           console.log("proposal.users_who_voted_yes = ", proposal.users_who_voted_yes);
           // If user had previously voted no, remove from users_who_voted_no array
           if (noVoteUserIndex >-1) {
                proposal.users_who_voted_no.splice(noVoteUserIndex, 1);
           }
        }

        // If every user in the group has voted, determine the outcome immediately
        if ((proposal.users_who_voted_yes.length + proposal.users_who_voted_no.length) === proposal.voting_members.length) {
            console.log("Every eligible member has voted on this proposal");
            if (proposal.users_who_voted_yes.length > proposal.users_who_voted_no.length) {
                console.log("This proposal has been enacted");
                proposal.status = 2;
            } else {
                console.log("This proposal has been rejected");
                proposal.status = 3;
            }
        }

        proposal.save();
        response.send(JSON.stringify(proposal));
    });
});

/*
 * URL /proposals/vote/no/:proposal_id - Adds a no vote to the proposal specified
 * by :id and records that the session user voted no on that proposal
 */
app.post('/proposals/vote/no/:proposal_id', function (request, response) {

    if (!request.session.email_address) {
        response.status(401).send("No user logged in");
        return;
    }

    console.log("Server received request to vote no on proposal with id", request.params.proposal_id);
    var proposal_id = request.params.proposal_id;
    var user_id = request.session.user_id;

    // Find the proposal with proposal_id
    // TODO: Add parameters to require that this proposal be up for vote
    Proposal.findOne({_id: proposal_id}).exec(function (err, proposal) {
        if (err) {
            // Query returned an error.
            response.status(400).send(JSON.stringify(err));
            return;
        }
        if (proposal === null) {
            // Query didn't return an error but didn't find the SchemaInfo object
            response.status(500).send('Proposal does not exist');
            return;
        }

        var noVoteUserIndex = proposal.users_who_voted_no.indexOf(user_id);
        var yesVoteUserIndex = proposal.users_who_voted_yes.indexOf(user_id);
        if (noVoteUserIndex >-1) {
           console.log("User has already voted no on this proposal");
        } else {
           console.log("User has not yet voted no on this proposal");
           proposal.users_who_voted_no.push(user_id);
           console.log("proposal.users_who_voted_no = ", proposal.users_who_voted_no);
           // If user had previously voted no, remove from users_who_voted_no array
           if (yesVoteUserIndex >-1) {
                proposal.users_who_voted_yes.splice(yesVoteUserIndex, 1);
           }
        }

        // If every user in the group has voted, determine the outcome immediately
        if ((proposal.users_who_voted_yes.length + proposal.users_who_voted_no.length) === proposal.voting_members.length) {
            console.log("Every eligible member has voted on this proposal");
            if (proposal.users_who_voted_yes.length > proposal.users_who_voted_no.length) {
                console.log("This proposal has been enacted");
                proposal.status = 2;
            } else {
                console.log("This proposal has been rejected");
                proposal.status = 3;
            }
        }        

        proposal.save();
        response.send(JSON.stringify(proposal));
    });
});

/************************
 * Server Configuartion *
 ************************/

var server = app.listen(process.env.PORT || 3000, function () {
    var port = server.address().port;
    console.log('Listening at port' + port + ' exporting the directory ' + __dirname);
});


